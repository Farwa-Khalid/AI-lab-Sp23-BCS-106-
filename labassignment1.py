# -*- coding: utf-8 -*-
"""LabAssignment1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-yg-sXqe74qP4MlevHhmlqMAm3y-BZVc

**Create a dictionary to store student information**
**Print all keys and values**
"""

student = {
    "name": "Mahaz Awan",
    "age": 20,
    "roll_number": "CS123",
    "grade": "B"
}
print("Student Information:")
for key, value in student.items():
    print(f"{key}: {value}")

"""**Update the grade of the student**"""

student["grade"] = "A"
print("\nUpdated grade:", student["grade"])

"""**Add a new key 'email' with a value**"""

student["email"] = "mahazawan@example.com"
print("\nAdded email:", student["email"])

"""**Delete the 'roll_number' key**"""

del student["roll_number"]
print("\nAfter deleting roll_number:")

"""**Print final dictionary**"""

for key, value in student.items():
    print(f"{key}: {value}")

"""**GRAPH TASKS**"""

# 1. Import the Matplotlib library
import matplotlib.pyplot as plt

# 2. Create data
X = [1, 2, 3, 4, 5]
Y = [2, 4, 6, 8, 10]

# 3. Create a simple line plot
plt.plot(X, Y, marker='o', color='blue', linestyle='-')

# Add title and labels
plt.title("Simple Line Plot")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")

# Add grid lines
plt.grid(True)

# Show the plot
plt.show()

"""**WATER JUG PROBLEM TASKS**"""

from collections import deque
import time
import tracemalloc

# Function to check if the state has been visited
def is_visited(state, visited):
    return state in visited

# Function to print the steps
def print_steps(path):
    for step in path:
        print(step)

# Function to get all possible next states
def get_next_states(state, jug1_cap, jug2_cap):
    jug1, jug2 = state
    states = []

    # Fill Jug1
    states.append((jug1_cap, jug2))
    # Fill Jug2
    states.append((jug1, jug2_cap))
    # Empty Jug1
    states.append((0, jug2))
    # Empty Jug2
    states.append((jug1, 0))
    # Pour Jug1 -> Jug2
    pour = min(jug1, jug2_cap - jug2)
    states.append((jug1 - pour, jug2 + pour))
    # Pour Jug2 -> Jug1
    pour = min(jug2, jug1_cap - jug1)
    states.append((jug1 + pour, jug2 - pour))

    return states

# BFS Implementation
def bfs(jug1_cap, jug2_cap, target):
    start = (0, 0)
    queue = deque([(start, [start])])
    visited = set()
    steps = 0

    while queue:
        state, path = queue.popleft()
        steps += 1
        jug1, jug2 = state

        if jug1 == target or jug2 == target:
            return path, steps

        visited.add(state)
        for next_state in get_next_states(state, jug1_cap, jug2_cap):
            if next_state not in visited:
                queue.append((next_state, path + [next_state]))

    return None, steps

# DFS Implementation
def dfs(jug1_cap, jug2_cap, target):
    start = (0, 0)
    stack = [(start, [start])]
    visited = set()
    steps = 0

    while stack:
        state, path = stack.pop()
        steps += 1
        jug1, jug2 = state

        if jug1 == target or jug2 == target:
            return path, steps

        visited.add(state)
        for next_state in get_next_states(state, jug1_cap, jug2_cap):
            if next_state not in visited:
                stack.append((next_state, path + [next_state]))

    return None, steps

# Compare BFS and DFS
def compare_algorithms():
    jug1_cap, jug2_cap, target = 4, 3, 2

    # BFS performance
    tracemalloc.start()
    start_time = time.time()
    bfs_path, bfs_steps = bfs(jug1_cap, jug2_cap, target)
    bfs_time = time.time() - start_time
    bfs_memory = tracemalloc.get_traced_memory()[1] / 1024
    tracemalloc.stop()

    # DFS performance
    tracemalloc.start()
    start_time = time.time()
    dfs_path, dfs_steps = dfs(jug1_cap, jug2_cap, target)
    dfs_time = time.time() - start_time
    dfs_memory = tracemalloc.get_traced_memory()[1] / 1024
    tracemalloc.stop()

    # Results
    print("==== BFS Results ====")
    print_steps(bfs_path)
    print(f"Steps: {bfs_steps}")
    print(f"Time taken: {bfs_time:.6f} sec")
    print(f"Memory used: {bfs_memory:.2f} KB\n")

    print("==== DFS Results ====")
    print_steps(dfs_path)
    print(f"Steps: {dfs_steps}")
    print(f"Time taken: {dfs_time:.6f} sec")
    print(f"Memory used: {dfs_memory:.2f} KB\n")

# Run comparison
compare_algorithms()

"""**MAZE TASKS**"""

import heapq

# Example grid format:
# 0 = free cell
# 1 = wall
# We'll index as grid[y][x] with origin (0,0) bottom-left or top-left depending on your preference.
# For this code let's assume grid[0] is row y=0 (bottom row) and x increases to the right.

def manhattan(a, b):
    (x1, y1), (x2, y2) = a, b
    return abs(x1 - x2) + abs(y1 - y2)

def neighbors(pos, width, height, grid):
    x, y = pos
    candidates = [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]
    result = []
    for nx, ny in candidates:
        if 0 <= nx < width and 0 <= ny < height:
            if grid[ny][nx] == 0:  # 0 = free
                result.append((nx, ny))
    return result

def a_star(start, goal, grid):
    height = len(grid)
    width = len(grid[0])
    open_heap = []
    heapq.heappush(open_heap, (manhattan(start, goal), 0, start))  # (f, g, node)
    parent = {start: None}
    gscore = {start: 0}
    closed = set()

    while open_heap:
        f, g, current = heapq.heappop(open_heap)
        if current in closed:
            continue
        if current == goal:
            # reconstruct path
            path = []
            n = current
            while n is not None:
                path.append(n)
                n = parent[n]
            path.reverse()
            return path
        closed.add(current)

        for nb in neighbors(current, width, height, grid):
            if nb in closed:
                continue
            tentative_g = g + 1
            if nb not in gscore or tentative_g < gscore[nb]:
                gscore[nb] = tentative_g
                parent[nb] = current
                f_nb = tentative_g + manhattan(nb, goal)
                heapq.heappush(open_heap, (f_nb, tentative_g, nb))
    return None  # no path

# -------------------------
# Build the grid for your maze:
# Determine the grid cell coordinates from the picture:
# - I suggest mapping letters A..Y to (x,y) coordinates using the axis printed on the picture.
# - Set grid[y][x] = 1 for every blue wall tile (blocked).
# Example below builds an empty 6x6 and you must mark walls manually.

width, height = 6, 6
grid = [[0]*width for _ in range(height)]

# Example: mark a wall at x=1, y=0:
# grid[0][1] = 1

# TODO: Fill the grid with walls from the picture.
# Use the picture's x (0..5) and y (0..5) coordinates to place walls.
# If you want, paste the wall coordinates here and I can fill them for you.

# Example start/end after you set up the grid:
start = (0, 0)   # coordinate for A (x,y)
goal  = (5, 5)   # coordinate for Y (x,y)

path = a_star(start, goal, grid)
if path:
    print("Path length:", len(path)-1, "moves")
    print("Path (x,y) from start to goal:")
    print(path)
else:
    print("No path found. Check walls / start / goal positions.")